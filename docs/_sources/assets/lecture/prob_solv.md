
# [Problem Solving]()

<style>
    iframe {width:100%;height:600px;}
</style>

```````` {div} full-width

```````    {tab-set}
``````     {tab-item} Figure It Out

<iframe width="100%" height="600" src="https://www.youtube.com/embed/6_LX9mo0Thw" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>
``````
``````     {tab-item} The Art of Problem Solving

<iframe width="100%" height="600" src="https://www.youtube.com/embed/oDGydfWkVhI" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>
``````
``````     {tab-item} Like a Computer Scientist

<iframe width="100%" height="600" src="https://www.youtube.com/embed/x77-gT8bWLo" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>

``````
``````     {tab-item} For Developers

<iframe  src="https://www.youtube.com/embed/x77-gT8bWLo" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>

``````
```````
````````

## [Overview]()

`````````` {div} full-width

``` {admonition} Definition
:class: seealso

> Problem-solving is the cognitive process of identifying, analyzing, and resolving challenges or issues in a systematic and logical manner. It involves the application of critical thinking, creativity, and analytical skills to find effective solutions to problems. Problem-solving is a fundamental skill in various domains, including computer science, mathematics, engineering, business, and everyday life.

```

````` {admonition} Key Aspects
:class: tip

```` {grid}
```  {grid-item} 
:columns: 4
Problem Identification
: Recognizing and defining the issue or challenge at hand. This requires clear understanding and accurate articulation of the problem.
```
```  {grid-item} 
:columns: 4
Analysis
: Breaking down the problem into smaller components and understanding its underlying factors, constraints, and potential causes.
```
```  {grid-item} 
:columns: 4
Generation of Solutions
: Generating a range of possible solutions or approaches to address the problem. This involves brainstorming and considering various perspectives.
```
```  {grid-item} 
:columns: 4
Evaluation
: Assessing the proposed solutions based on criteria such as feasibility, efficiency, effectiveness, and ethical considerations.
```
```  {grid-item} 
:columns: 4
Selection of Optimal Solution
: Choosing the most appropriate solution or combination of solutions that best address the problem while considering potential trade-offs.
```
```  {grid-item} 
:columns: 4
Implementation
: Executing the chosen solution by applying relevant strategies, techniques, and resources.
```
```  {grid-item} 
:columns: 4
Reflection
: Reflecting on the effectiveness of the chosen solution and analyzing the outcomes. This step often leads to further refinement or adjustments if necessary.
```

````
`````

````` {admonition} Note...
Problem-solving is not limited to a single approach or methodology. It often requires a combination of logical reasoning, creative thinking, domain knowledge, and practical experience. Successful problem-solving involves adapting strategies based on the complexity of the problem and the context in which it arises.

Problem-solving through programming entails using coding and algorithms to develop software solutions for various challenges. This involves translating real-world problems into computational frameworks, designing efficient algorithms, and implementing code to achieve desired outcomes.
`````

`````` {admonition} Techniques

````` {grid}
````  {grid-item}
:columns: 4
``` {dropdown} Algorithmic Thinking
Teach students to approach problems algorithmically. Break down problems into step-by-step instructions that a computer can execute. This involves defining the problem, identifying inputs and outputs, and outlining the logic required to transform inputs into desired outputs.
```
````
````  {grid-item}
:columns: 4
``` {dropdown} Divide and Conquer
Introduce the divide and conquer strategy, where complex problems are divided into smaller, more manageable subproblems. Students can solve these subproblems individually and combine their solutions to solve the larger problem.
```
````
````  {grid-item}
:columns: 4
``` {dropdown} Dynamic Programming
Teach students about dynamic programming, a technique used to solve problems by breaking them down into overlapping subproblems and storing intermediate results to avoid redundant calculations.
```
````
````  {grid-item}
:columns: 4
``` {dropdown} Greedy Algorithms
Discuss greedy algorithms, which make locally optimal choices at each step with the hope of finding a global optimum solution. Emphasize situations where greedy algorithms are effective and their limitations.
```
````
````  {grid-item}
:columns: 4
``` {dropdown} Backtracking
Introduce backtracking, a technique for solving problems incrementally by trying out different possibilities and backtracking when a solution is not feasible. This is particularly useful for combinatorial problems.
```
````
````  {grid-item}
:columns: 4
``` {dropdown} Simulation and Modeling
Encourage students to simulate real-world scenarios using programming. This technique is valuable for testing and understanding complex systems before implementing them.
```
````
````  {grid-item}
:columns: 4
``` {dropdown} Data Structures
Teach students how to choose and implement appropriate data structures for different problem-solving scenarios. This includes arrays, linked lists, stacks, queues, trees, and graphs.
```
````
````  {grid-item}
:columns: 4
``` {dropdown} Optimization Techniques
Discuss optimization techniques that involve minimizing or maximizing a certain metric. This is applicable to various scenarios such as resource allocation, scheduling, and network flow problems.
```
````
````  {grid-item}
:columns: 4
``` {dropdown} Debugging and Testing
Emphasize the importance of effective debugging and testing techniques. Teach students how to identify and fix errors in their code systematically.
```
````
````  {grid-item}
:columns: 4
``` {dropdown} Problem Decomposition
Encourage students to decompose complex problems into smaller, manageable subproblems. This helps in solving each subproblem individually and combining the solutions to solve the overall problem.
```
````
````  {grid-item}
:columns: 4
``` {dropdown} Real-World Applications
Provide real-world problem scenarios from different domains, such as business, science, and engineering. This helps students see the practical applications of problem-solving through programming.
```
````
````  {grid-item}
:columns: 4
``` {dropdown} Iterative Development
Teach students to iterate on their solutions, gradually refining and improving their code as they gain a deeper understanding of the problem and potential edge cases.
```
````
````  {grid-item}
:columns: 4
``` {dropdown} Code Reusability
Emphasize the importance of writing modular and reusable code. This enables students to apply solutions to similar problems in the future.
```
````
````  {grid-item}
:columns: 4
``` {dropdown} Collaboration and Communication
Encourage students to collaborate on problem-solving tasks, discussing ideas and approaches with peers. Communication skills are essential for successful teamwork.
```
````
````  {grid-item}
:columns: 4
``` {dropdown} Efficiency and Complexity Analysis
Introduce students to analyzing the efficiency of their algorithms in terms of time and space complexity. This helps them choose the most appropriate solution for different scenarios.
```
````
`````
``````

``````````

### In practice

`````` {div} full-width
````` {admonition} Steps to successful problem solving
:class: tip

1. Understand the Problem
    - Before attempting to solve a problem, make sure you have a clear and complete understanding of the problem statement. Define the problem, identify the inputs and outputs, and clarify any constraints or requirements.
2. Break Down the Problem
    - Divide the problem into smaller, manageable subproblems. This makes it easier to approach and solve complex challenges step by step.
3. Explore Multiple Perspectives
    - Look at the problem from different angles. Consider various approaches and solutions before settling on one. This can lead to more innovative and effective solutions.
4. Plan and Strategize
    - Develop a plan or strategy for solving the problem. Decide on the algorithms, data structures, and techniques you'll use. This planning phase can save time and prevent unnecessary mistakes.
5. Start with Simple Cases
    - Begin by solving simpler or smaller instances of the problem. This can help you gain insight into the problem's structure and develop a foundation for tackling more complex cases.
6. Iterative Approach
    - Solve the problem iteratively, gradually building upon your solution. This allows you to address challenges incrementally and refine your approach as you progress.
7. Use Test Cases
    - Test your solution using various test cases, including edge cases and corner cases. This helps ensure that your solution works correctly in a variety of scenarios.
8. Debugging and Refinement
    - If you encounter errors or unexpected behavior, systematically debug your code to identify and fix issues. Refine your solution based on the feedback from testing.
9. Optimization
    - Once you have a working solution, analyze its efficiency. Consider time complexity and space complexity and aim to optimize your code for better performance if possible.
10. Documentation
    - Document your solution, explaining your thought process, the rationale behind your decisions, and any assumptions made. Clear documentation is valuable for understanding and maintaining your code.
11. Collaboration
    - If appropriate, collaborate with others. Discussing the problem with peers can provide fresh insights and lead to more creative solutions.
12. Learn from Mistakes
    - Embrace mistakes as opportunities to learn and improve. Analyze what went wrong and how you can avoid similar issues in the future.
13. Continuous Improvement
    - Problem-solving is a skill that can be refined over time. Continuously seek ways to enhance your problem-solving abilities by tackling diverse challenges and learning from experience.
14. Stay Persistent
    - Complex problems can be challenging, but persistence is key. Don't give up easily; keep exploring different approaches and refining your solutions.
15. Reflect and Iterate
    - After solving a problem, take time to reflect on your approach and its outcomes. Consider how you can apply the lessons learned to future challenges.

`````
``````

### Breaking Down Problems

`````````` {div} full-width
`````````  {card}

``` {figure} https://nickjanetakis.com/assets/blog/cards/breaking-down-problems-is-the-number-1-software-developer-skill-2aa98dfabbd1e6823259bbba94e6f0b297c4a50b41819558b0df8104052f52e2.jpg
```

```````    {tab-set}

``````     {tab-item} Understanding the Problem

Before diving into coding, it's essential to grasp the problem's context and requirements thoroughly. Define the problem's scope, inputs, expected outputs, and any constraints. This step sets the foundation for your problem-solving journey.
``````

``````     {tab-item} Decomposition Strategies

Divide and Conquer
: Adopt the "divide and conquer" approach. Break the problem into smaller subproblems that are easier to understand and solve independently. Address each subproblem before combining solutions to solve the overall problem.

Functional Decomposition
: Divide the problem based on different functionalities or tasks required. Create functions or modules to handle specific aspects of the problem, promoting code modularity and reusability.

Data Decomposition
: If the problem involves handling multiple data entities, consider decomposing it based on the data's attributes. Develop data structures that represent these attributes and build your solution around them.

``````

``````     {tab-item} Visualization Techniques
```` {grid}
```  {grid-item} 
:columns: 6
Top-Down Approach
: Start with a high-level view of the problem and gradually refine your solution by adding details. This approach aids in understanding the problem holistically before delving into specifics.
```
```  {grid-item} 
:columns: 6
Bottom-Up Approach
: Begin by solving individual components or subproblems and then combine them to create a complete solution. This approach allows you to focus on getting the core functionality right before expanding.
```
````
``````

``````     {tab-item} Modularization and Reusability
```` {grid}
```  {grid-item} 
:columns: 6
Modular Design
: Design your solution using small, self-contained modules or functions. Each module should have a specific purpose, making the overall solution more organized and easier to manage.
```
```  {grid-item} 
:columns: 6
Code Reusability
: Create reusable code snippets that can be utilized in various parts of the solution or in future projects. This saves time and promotes efficient coding practices.
```
````
``````

``````     {tab-item} Testing and Feedback
```` {grid}
```  {grid-item} 
:columns: 6
Incremental Testing
: Test each module or subproblem as you solve it. This early testing helps identify errors and ensures that individual components function correctly before integration.
```
```  {grid-item} 
:columns: 6
Feedback Loop
: Seek feedback from peers or instructors on your approach. An external perspective can highlight overlooked aspects and lead to improvements in your solution.
```
````
``````
``````     {tab-item} Summary

Problem-solving with programming involves a systematic breakdown of complex challenges. By understanding the problem, employing decomposition strategies, visualizing the solution, and approaching the problem from different angles, you can effectively navigate intricate programming tasks. These strategies serve as valuable tools as you continue your academic journey in engineering, equipping you with the skills to tackle diverse problems with confidence and precision.

``````
```````
`````````
``````````